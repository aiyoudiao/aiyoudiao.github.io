(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{557:function(e,t,a){"use strict";a.r(t);var r=a(18),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("读了前三章，了解了虚拟dom的局部更新的设计思路，也知道了vue这个框架的开发体验、框架体积控制、剔除无用代码、不同资源输出格式、特性开关、错误处理、TS支持等等，它们互相配合，从而大大的降低了开发者的心智压力，这些也是衡量一个框架的质量指标，vue做的很好。"),a("br"),e._v("\nvue3中通过声明式的模板UI，编译器将模板或组件转成虚拟dom，再由渲染器转成真实dom，编译器中做了优化，从而使得渲染器能够更快找到变更的元素，性能上得到了很大的优化。")]),e._v(" "),a("h2",{attrs:{id:"副作用函数和响应式数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副作用函数和响应式数据"}},[e._v("#")]),e._v(" 副作用函数和响应式数据")]),e._v(" "),a("p",[e._v("副作用函数就是 这个函数中做了影响其它的事情，比如你改变了全局的变量，而其它地方也用到了这个全局变量。直接或者间接的让其它地方受到影响，这就是副作用。")]),e._v(" "),a("p",[e._v("响应式数据就是 当某个数据发生变化，就会立刻执行一个行为，比如你给a赋值，a发生了变化，然后就立马触发一个行为，在这个行为里将b的数据也做了同步的更新。响应式，就是get、set、delete 之后立马执行相应的行为，从而使得其它地方也随之发生变化。")]),e._v(" "),a("h2",{attrs:{id:"响应式数据的基本实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据的基本实现"}},[e._v("#")]),e._v(" 响应式数据的基本实现")]),e._v(" "),a("p",[e._v("拦截一个对象的get和set操作，给get和set绑定一个行为(副作用函数)。"),a("br"),e._v("\n在ES2015之前使用Object.defineProperty，在ES2015之后可以使用浏览器内置的Proxy来实现。"),a("br"),e._v("\nvue2中用的是第一种，vue3中用的是第二种。第一种只能拦截某个变量，当对象层级很多时，需要递归的调用Object.definePropery。第二种可以直接拦截整个对象。"),a("br"),e._v("\nvue中是在get的时候添加副作用函数，set的时候循环调用之前添加过的副作用函数。这样set时就会通知所有订阅过当前目标的其它群体。")]),e._v(" "),a("h2",{attrs:{id:"设计一个完善的响应系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计一个完善的响应系统"}},[e._v("#")]),e._v(" 设计一个完善的响应系统")]),e._v(" "),a("p",[e._v("Proxy默认监听一整个对象，也就是说这个对象任何一个key被get或者set都会收集副作用函数或触发副作用函数。这样就会出问题。"),a("br"),e._v("\n所以vue中采用了将对象的引用作为第一层key，第一层key对应的是一个Map，该对象的属性key作为第二层key，第二层key对应的是Set,Set存的是副作用函数。")]),e._v(" "),a("p",[e._v("大概是 WeakMap->Map->Set这样的一层嵌套结构，好处是WeakMap以对象为key时是弱引用的，只要这个对象被回收掉了，那么WeakMap中这部分相关的数据就会被销毁，从而不会影响垃圾回收机制的执行，从而使用它更加友好。")]),e._v(" "),a("p",[e._v("通过这样的树结构，精确的解决了监听一整个对象时任何一个key被get或者set时都会收集副作用函数或触发副作用函数的问题，从而能够和每一个key建立对应的关系，不会出现错误的行为。")]),e._v(" "),a("p",[e._v("vue中还将Proxy的get中收集副作用函数与set中触发副作用的函数的操作做了封装，封装成了track和trigger函数，这样一来代码可读性就更好了。非常棒。")]),e._v(" "),a("h2",{attrs:{id:"分支切换与cleanup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支切换与cleanup"}},[e._v("#")]),e._v(" 分支切换与cleanup")]),e._v(" "),a("p",[e._v("Proxy中监听一整个对象，也就是对象中任何一个key被get，就会收集副作用函数。如果副作用函数中使用if else这样的条件分支，if小括号中把对象的key进行了get，然后if大括号中也把对象的另一个key进行了get，那么这两个key都会收集这个副作用函数的依赖。这时就会导致该对象的两个key任何一次set操作，都会触发这个副作用函数。"),a("br"),e._v("\n似乎没啥不对，但这时f小括号中的值你设置为了false，那么按道理来说应该清除之前给if大括号中给该对象另一个key进行get时的收集的依赖清除掉。但实际上默认并不会这么做，因为你已经收集，那么还是会在你set该对象另一个key时触发这个副作用函数，这样就不对。"),a("br"),e._v("\n这就是在副作用函数中分支切换时要注意的地方，也就是要做cleanup操作。")]),e._v(" "),a("p",[e._v("这个时候可以注册副作用函数的时候声明一个与该副作用函数相关的所有依赖集合的数组，在被监听的对象每一个key被get的时候，将其所有的副作用函数装入这个数组中。"),a("br"),e._v("\n那么在注册某个副作用函数的时候，先遍历一遍该副作用函数的收集到的依赖集合，从那些依赖集合中剔除掉当前注册的这个副作用函数，最后就能够在get的时候重新收集了，不会出现重复的收集和多余的收集了。类似于先清空之前收集的相关依赖，再收集最新的那一个。")]),e._v(" "),a("p",[e._v("综上所述似乎OK了，但由于cleanup是在被注册的副作用函数被执行的时候触发，也就是对象的key被set的时候会触发。虽然cleanup是在移除多余收集的副作用函数，副作用函数时放到Set中的，但是Set有一个特性，当它在遍历的时候，如果被移除了，那么它会再次被添加进这个Set中。"),a("br"),e._v("\n那么这样一来就造成了循环，我刚遍历完这个，这个也被我删除了，然后Set中又把它加进来了，总之烦死了。这时候可以在遍历整个Set之前，拷贝一份新的，去遍历那个新的，在新的副作用函数被调用时，就会正常cleanup旧的Set中的副作用函数，新的不会被删除，就不会被再次添加进去。这样就绕过了Set的这个特性带来的问题了，这也是它的forEach的规范带来的问题。")])])}),[],!1,null,null,null);t.default=v.exports}}]);