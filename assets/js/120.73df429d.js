(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{454:function(e,r,v){"use strict";v.r(r);var t=v(3),_=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("vue3的设计与实现这本书终于到手了噢，还有作者的亲笔签名以及大圣老师的传奇玉玺印。可不能辜负了大圣老师的美意，所以我决定每看一掌都会写一些心得。")]),e._v(" "),r("p",[e._v("权衡的艺术，看到这个名字，我瞬间脑袋就像个灯泡一样，瞬间一亮。我喜欢，我很想知道vue权衡的艺术，就像上帝为什么要造人一样的艺术(狗头)。好了，开始。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/HcySunYang/code-for-vue-3-book",target:"_blank",rel:"noopener noreferrer"}},[e._v("书中源码"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"dom编程的两种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dom编程的两种方式"}},[e._v("#")]),e._v(" DOM编程的两种方式")]),e._v(" "),r("p",[e._v("命令式与声明式")]),e._v(" "),r("p",[e._v("作为一个曾经实现过JQuery的人来说，印象是很深刻的，JQuery是基于原生js做了一层封装，封装了很多简易操作的功能。比如DOM的增删改查、简单动画的切入、请求与处理等等。"),r("br"),e._v("\n虽然JQuery是一个类库，但是还是避免不了他基于过程的操作方式，它只是简化过程，但实际上还是在一步一步的操作DOM。")]),e._v(" "),r("p",[e._v("命令式编程更加注重过程，操作DOM是一步一步的来，你需要了解这个具体逻辑以及每一个API的效果，才能够实现你想要的操作DOM的效果。虽然有了JQuery，但是还是会有很多冗余代码。")]),e._v(" "),r("p",[e._v("vue在2016年就开始接触，当时在读大一的觉得它好神奇噢，居然能自动改变数据。那时候我们还在学C#的webform aspx，里面有类似功能的插件，后来发现它是用viewstate和隐藏域来实现的。而vue是纯前端的实现，当时能想到的是 它应该是个观察者，然后通过字符串的替换操作来将 插值运算符改成实际的结果。至于它为啥那么准确的定位，我当时觉得应该是加了id，所以才那么准确的。")]),e._v(" "),r("p",[e._v("声明式编程更加注重结果，不需要你写那么多操作DOM步骤，你只要按照它的方式去声明，就能够自动的帮你操作DOM了，非常的方便，代码看起来更加灵动些。")]),e._v(" "),r("h2",{attrs:{id:"权衡性能与可维护性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#权衡性能与可维护性"}},[e._v("#")]),e._v(" 权衡性能与可维护性")]),e._v(" "),r("p",[e._v("看到这章让我非常感兴趣，很久以前我想过，都说MVVM框架性能很好，但是它引入了那么多代码进去，怎么可能性能好，肯定没有原生的好。因此也曾一度排斥这种框架，以助于后来参加工作了，第一个项目就没用vue而是用JQuery+面向对象的设计模式来封装一个MVC框架来用，感觉那样更加符合大学里的编程方式。"),r("br"),e._v("\n不过后来发现我错了，vue是真香，让我的开发效率提高了很多，从而有很多时间去学更多新东西，而不是冗余的业务代码写很多遍。")]),e._v(" "),r("p",[e._v("vue的是个框架，一般来说框架的性能都不会比你原生操作的性能要好。毕竟不管你用不用，框架都会封装很多层，这么多层，每一层耗费的性能加起来肯定比你直接操作的性能要高。"),r("br"),e._v("\n当然那得是在你了解浏览器的一些原理与特性的基础上，不然在遇到复杂问题时，你写的原生代码未必要比框架的性能高。")]),e._v(" "),r("p",[e._v("vue这个框架给我们带来了开发效率高以及可维护性高的这样诸如此类的好处。毕竟如果你开发项目写成片成片的原生代码，写的时候逻辑是从上往下的没问题，但是代码量会巨长。并且在你不写成片的注释的时候，过几个月你再看，势必会头晕。这个我经历过，一个js文件几千行，密密麻麻的密集恐惧症。")]),e._v(" "),r("h2",{attrs:{id:"虚拟dom的性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的性能"}},[e._v("#")]),e._v(" 虚拟DOM的性能")]),e._v(" "),r("p",[e._v("创建DOM的时候，通过虚拟DOM来创建DOM是没有你直接创建DOM的性能好。毕竟手动创建DOM我就直接创建了，而虚拟DOM是需要你根据js对象来映射的创建真实DOM。")]),e._v(" "),r("p",[e._v("更新DOM的时候，通过虚拟DOM来更新DOM比你直接更新DOM的性能好，这个在更新的DOM内容越多时越明显。因为你直接更新DOM，比如JQuery，它是不存在复用原来的DOM的，会整片更新，而虚拟DOM是先对比再把有数据变更的DOM更新掉，会复用原来的DOM，非常的精准。")]),e._v(" "),r("p",[e._v("在实际开发中使用虚拟DOM 心智压力小，使用原生JS 心智压力大。")]),e._v(" "),r("h2",{attrs:{id:"运行时和编译时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时和编译时"}},[e._v("#")]),e._v(" 运行时和编译时")]),e._v(" "),r("p",[e._v("书中写了三种，运行时、编译时+运行时、编译时。")]),e._v(" "),r("p",[e._v("运行时，就是有个render函数，会在运行的时候调用render函数，从而将你手写的js对象(虚拟dom)转成DOM。"),r("br"),e._v("\n编译时+运行时，就是有个compiler函数和render函数，compiler函数可以将你写的html字符串转成虚拟dom对象，然后render函数将你的虚拟dom对象转成DOM。\n编译时，就是有个compiler函数直接把你的html字符串转成操作DOM的原生js操作，从而没有额外的将虚拟dom转成DOM的那些操作。")]),e._v(" "),r("p",[e._v("vue 是前两种，而Sevlte是最后一种，之前我做过的一个在线md绘图小工具就是基于官方的Sevlte开源项目做的 "),r("a",{attrs:{href:"http://www.hao6.website:999/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Graphic Live Editor"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("第一章让我对vue产生了极大的兴趣噢，之前我对编程都有点厌倦了，看到这本书真的让我又一次焕然而生，就像回到大学时，茶饭不思除了睡觉就是编程的时候。")]),e._v(" "),r("p",[e._v("vue权衡的艺术是 为了降低开发者的使用心智以及开发项目的可维护性，从而创造出这款框架，从性能上来说，可能没有高质量的原生的js操作性能好，但是入手成本低，并且开发出的程序可维护性很高，在大多数情况下性能性能还是很不错的。")]),e._v(" "),r("p",[e._v("虚拟dom的性能在更新时很不错，因为它是真正的局部更新，而不是一直都是偷懒的整片更新，性能损耗的操作是 diff差异时的操作 和 直接修改有变化部分的操作。通过找到差异的地方局部更新，这也是虚拟dom的最佳表现。")])])}),[],!1,null,null,null);r.default=_.exports}}]);