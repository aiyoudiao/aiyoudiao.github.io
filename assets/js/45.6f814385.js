(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{544:function(e,t,v){"use strict";v.r(t);var _=v(19),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[e._v("React只做两件事，一件事是渲染ui，一件事是响应事件。"),v("br"),e._v("\nmvc和mvvm都是早些年angular的设计理念。react并不是什么mvvm和mvc，它只是一个很小的东西，只做那两件事儿。它只是个工具。backbone才是真正的mvc，它是模仿java的spring，挪到前端来了。")]),e._v(" "),v("p",[e._v("上一篇文章中基础的工程搭建完毕，基础的语法也知悉了，那么开始弄一个todolist 练练手。学任何一门框架或者语言，都可以用todolist来练练手噢，也就是增删改查的逻辑尽快熟悉并上手。")]),e._v(" "),v("h2",{attrs:{id:"基础语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础语法"}},[e._v("#")]),e._v(" 基础语法")]),e._v(" "),v("p",[e._v("React 中 JSX 语法：render 函数中只能有一个根节点，所以你写的多个 html 标签必须包含在一个容器中，比如"),v("code",[e._v("<div></div>")]),e._v("中。")]),e._v(" "),v("p",[e._v("如果你不想页面中"),v("code",[e._v("多一个div包在你众多html标签外面")]),e._v("，可以通过引入 "),v("code",[e._v("import React, {Component, Fragment} from 'react'")]),e._v("来引入 "),v("code",[e._v("Fragment")]),e._v("，然后用"),v("code",[e._v("Fragment")]),e._v("替换掉"),v("code",[e._v("render")]),e._v("函数中外层包裹着"),v("code",[e._v("div")]),e._v("，这样就能够在渲染页面时"),v("code",[e._v("只显示你")]),e._v("写的"),v("code",[e._v("众多html标签")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"响应式设计思想和事件绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式设计思想和事件绑定"}},[e._v("#")]),e._v(" 响应式设计思想和事件绑定")]),e._v(" "),v("p",[e._v("你可以通过 "),v("code",[e._v("this.state={}")]),e._v(" 来存储数据，这样你就能够在 JSX 中使用了。"),v("br"),e._v("\n如果你想在"),v("code",[e._v("JSX")]),e._v("中使"),v("code",[e._v("用js")]),e._v("的"),v("code",[e._v("表达式")]),e._v("或者"),v("code",[e._v("变量")]),e._v("，你必须使用"),v("code",[e._v("{}")]),e._v("括起来。")]),e._v(" "),v("p",[e._v("在 JSX 语法中如果你"),v("code",[e._v("给")]),e._v("一个"),v("code",[e._v("标签设置")]),e._v("了"),v("code",[e._v("值")]),e._v("，如"),v("code",[e._v("input")]),e._v("标签的"),v("code",[e._v("value")]),e._v("，你设置了"),v("code",[e._v("{this.state.inputValue}")]),e._v("，那么你给"),v("code",[e._v("this.state.inputValue")]),e._v("设置了值，就会"),v("code",[e._v("导致")]),e._v("你的"),v("code",[e._v("输入框")]),e._v("中就"),v("code",[e._v("无法输入值")]),e._v("了。")]),e._v(" "),v("p",[e._v("除非你绑定"),v("code",[e._v("onChange")]),e._v("事件，这个"),v("code",[e._v("onChange")]),e._v("事件与"),v("code",[e._v("onchange")]),e._v("事件不同，这是"),v("code",[e._v("JSX")]),e._v("中的，所以你给他添加的方法还是需要用"),v("code",[e._v("{}")]),e._v("括号括起来。")]),e._v(" "),v("p",[e._v("在"),v("code",[e._v("给事件绑定方法")]),e._v("时，必须要这样，"),v("code",[e._v("onChange= {this.changeHandler.bind(this)}")]),e._v("，不然"),v("code",[e._v("this指向")]),e._v("会有问题，或者"),v("code",[e._v("onChange={() => {this.changeHandler()}}")]),e._v(",因为"),v("code",[e._v("箭头函数")]),e._v("就"),v("code",[e._v("是匿名函数")]),e._v("使"),v("code",[e._v("用了bind(this)")]),e._v("。")]),e._v(" "),v("p",[e._v("事件绑定的方法里你可以通过"),v("code",[e._v("e.target")]),e._v("来获取你输入的值，这时候你可以通过以下的方式来让文本框中的值改变。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    this.setState({this.state.inputValue: e.target.value});\n")])])]),v("p",[v("code",[e._v("React")]),e._v("只能够直接"),v("code",[e._v("以数据驱动视图")]),e._v("，并不能"),v("code",[e._v("直接")]),e._v("以视图来改变数据"),v("code",[e._v("，而且如果你使用")]),e._v("this.state.inputValue= e.target.value;"),v("code",[e._v("那也是")]),e._v("无效"),v("code",[e._v("的，它只能使用")]),e._v("this.setState"),v("code",[e._v("来进行")]),e._v("修改state"),v("code",[e._v("中的值。它")]),e._v("不像vue"),v("code",[e._v("那种")]),e._v("响应式监听"),v("code",[e._v("，自动给你修改")]),e._v("data"),v("code",[e._v("中的值，这也是")]),e._v("它"),v("code",[e._v("和")]),e._v("vue"),v("code",[e._v("的")]),e._v("不同点`。")]),e._v(" "),v("h2",{attrs:{id:"todolist-新增、删除功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#todolist-新增、删除功能"}},[e._v("#")]),e._v(" TodoList 新增、删除功能")]),e._v(" "),v("p",[v("code",[e._v("es6")]),e._v("中有一个"),v("code",[e._v("展开运算符")]),e._v(": "),v("code",[e._v("...")]),e._v("，如"),v("code",[e._v("[...[1,2,3,4]]")]),e._v(" 会把数组中的元素一个个的展开，变成这样"),v("code",[e._v("[1,2,3,4]")]),e._v("，也就是把原数组中的元素放入了新数组中，也可以在对象中使用。")]),e._v(" "),v("p",[e._v("你在"),v("code",[e._v("this.setState")]),e._v("中加的"),v("code",[e._v("{}")]),e._v("里面的"),v("code",[e._v("成员")]),e._v("都会"),v("code",[e._v("变")]),e._v("成"),v("code",[e._v("this.state")]),e._v("的"),v("code",[e._v("成员")]),e._v("。这表示将原来的"),v("code",[e._v("this.state.list")]),e._v("平铺到新的数组中，并且还将"),v("code",[e._v("this.state.inputValue")]),e._v("添加进去。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    this.setState({list: [...this.state.list, this.state.inputValue]});\n")])])]),v("p",[e._v("可以将已经添加的文本框中的值"),v("code",[e._v("清空")]),e._v("掉。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    this.setState({list: [...this.state.list, this.state.inputValue], this.state.inputValue: ''});\n")])])]),v("p",[e._v("在 React 中你做循环渲染标签的时候一定要给这个标签添加一个 key 属性，属性值可以赋值为 index，但是在实际的编程中，使用 index 作为 key 值是一个不好的习惯。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    <ul>\n        {\n            this.state.list.map((item,index) => {\n                retrun (<li key = {index}>{item}</li>)\n            })\n        }\n    </ul>\n")])])]),v("p",[e._v("React 中有一个规则叫"),v("code",[e._v("immutable")]),e._v(" ，表示"),v("code",[e._v("state 不允许")]),e._v("我们"),v("code",[e._v("做")]),e._v("任何的"),v("code",[e._v("改变")]),e._v("，不然"),v("code",[e._v("性能优化")]),e._v("方面就会"),v("code",[e._v("出现问题")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    // 所以你删除的时候不允许直接用下面这种方式\n    // this.state.list.splice(index, 1);\n\n    // 需要你拷贝一个副本\n    const list = [...this.state.list];\n    list.splice(index, 1);\n    this.setState({\n        list: list\n    });\n")])])]),v("h2",{attrs:{id:"jsx-细节语法补充"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jsx-细节语法补充"}},[e._v("#")]),e._v(" JSX 细节语法补充")]),e._v(" "),v("p",[e._v("JSX 中"),v("code",[e._v("大写字母开头")]),e._v("的标签"),v("code",[e._v("表示")]),e._v("这是一个"),v("code",[e._v("组件")]),e._v("，"),v("code",[e._v("小写字母开头")]),e._v("的标签表示这是一个"),v("code",[e._v("html元素")]),e._v("。"),v("br"),e._v(" "),v("code",[e._v("{/* 注释内容 */}")]),e._v(" 是 JSX 中的"),v("code",[e._v("注释")]),v("br"),e._v("\nJSX 中添加"),v("code",[e._v("类名")]),e._v("和 "),v("code",[e._v("style")]),e._v("，"),v("code",[e._v('className = "box"')]),e._v("，"),v("code",[e._v("style = { {color: red} }")]),e._v("。"),v("br"),e._v("\nJSX 中 使用"),v("code",[e._v("label")]),e._v("标签时使用"),v("code",[e._v("for")]),e._v("时要"),v("code",[e._v("改")]),e._v("为"),v("code",[e._v("htmlFor")])]),e._v(" "),v("h2",{attrs:{id:"jsx-中不去转义-手动输入的-html-标签"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jsx-中不去转义-手动输入的-html-标签"}},[e._v("#")]),e._v(" JSX 中不去转义 手动输入的 Html 标签")]),e._v(" "),v("p",[e._v("也就是页面文本框中输入 "),v("code",[e._v("<h1>xxxx</h1>")]),e._v(" 在页面中显示时会被"),v("code",[e._v("转义")]),e._v("成下面这样。")]),e._v(" "),v("div",{staticClass:"language-html extra-class"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[e._v("    "),v("span",{pre:!0,attrs:{class:"token entity named-entity",title:"&it;"}},[e._v("&it;")]),e._v("h1"),v("span",{pre:!0,attrs:{class:"token entity named-entity",title:">"}},[e._v("&gt;")]),e._v("xxxx"),v("span",{pre:!0,attrs:{class:"token entity named-entity",title:"&it;"}},[e._v("&it;")]),e._v("/h1"),v("span",{pre:!0,attrs:{class:"token entity named-entity",title:">"}},[e._v("&gt;")]),e._v("\n")])])]),v("p",[e._v("通过给对应的标签 "),v("code",[e._v("加")]),e._v("上 "),v("code",[e._v("dangerouslySetInnerHTML = { {__html: <h1>xxx</h1>} }")]),e._v("，表示"),v("code",[e._v("危险")]),e._v("的设置"),v("code",[e._v("InnerHTML")]),e._v("内容，这样就会存在被"),v("code",[e._v("xss攻击")]),e._v("的可能。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    // 因为写了dangerouslySetInnerHTML 所以li标签对中的item就没必要写了\n    <li key={index} dangerouslySetInnerHTML = {{__html:item}}><li>\n")])])]),v("h2",{attrs:{id:"拆分组件与组件之间的传值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拆分组件与组件之间的传值"}},[e._v("#")]),e._v(" 拆分组件与组件之间的传值")]),e._v(" "),v("p",[e._v("组件会变成一个树形的结构，因为一个大的组件中会有很多个小组件，小组件中又有其它的更小的组件。")]),e._v(" "),v("p",[v("code",[e._v("父")]),e._v("组件"),v("code",[e._v("传")]),e._v("递"),v("code",[e._v("子")]),e._v("组件"),v("code",[e._v("数据")]),e._v("的"),v("code",[e._v("方式")]),e._v("，直接"),v("code",[e._v("在子组件中添加属性")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    // 给子组件传递一个content属性\n    <TodoList content = {this.state.inputValue} />\n\n    // 子组件中通过 this.props.属性名来使用\n    <div>{this.props.content}<div>\n")])])]),v("p",[e._v("如果你嫌每次绑定事件的方法都写"),v("code",[e._v(".bind(this)")]),e._v("，那么你可以把这一步放到"),v("code",[e._v("constructor")]),e._v("中去做,这样可以"),v("code",[e._v("节约一些性能")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    constructor (props) {\n        super(props);\n        this.handleClick = this.handleClick.bind(this);\n    }\n")])])]),v("p",[e._v("当你给"),v("code",[e._v("子")]),e._v("组件"),v("code",[e._v("传递父")]),e._v("组件中的"),v("code",[e._v("方法")]),e._v("，记得"),v("code",[e._v("给方法加")]),e._v("上一个"),v("code",[e._v(".bind(this)")]),e._v("，不然"),v("code",[e._v("子")]),e._v("组件"),v("code",[e._v("调用")]),e._v("时"),v("code",[e._v("会出现this指向问题")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"todolist-代码优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#todolist-代码优化"}},[e._v("#")]),e._v(" TodoList 代码优化")]),e._v(" "),v("p",[e._v("通过代码解构来优化代码。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    const {content} = this.props;\n    //上面这行代码表示 将this.props.content 赋值给content\n    //const content = this.props.content;\n")])])]),v("p",[e._v("将"),v("code",[e._v("样式")]),e._v("的引入"),v("code",[e._v("放")]),e._v("到引入"),v("code",[e._v("组件")]),e._v("的"),v("code",[e._v("后")]),e._v("面，"),v("code",[e._v("将")]),e._v("事件绑定的方法中需要"),v("code",[e._v(".bind(this)")]),e._v("的写法，"),v("code",[e._v("统一")]),e._v("的放"),v("code",[e._v("到")]),e._v("构造函数中"),v("code",[e._v(",这样 JSX 中")]),e._v("调用方法"),v("code",[e._v("时就")]),e._v("不必"),v("code",[e._v("每次都.bind(this)")]),e._v("了。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    constructor (props) {\n        super(props);\n        this.handleClick = this.handleClick.bind(this);\n    }\n")])])]),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    <div onClick = {this.handleClick}></div>\n")])])]),v("p",[e._v("如果你将 "),v("code",[e._v("遍历列表")]),e._v("的"),v("code",[e._v("操作")]),e._v("直接"),v("code",[e._v("放")]),e._v("到"),v("code",[e._v("JSX")]),e._v("中会"),v("code",[e._v("显得代码过于臃肿")]),e._v("，那么你可以"),v("code",[e._v("写一个方法")]),e._v("，然后"),v("code",[e._v("在JSX中")]),e._v("直接"),v("code",[e._v("调用")]),e._v("你写的方法"),v("code",[e._v("即可")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    <div>{this.getListItem()}</div>\n\n    getListItem(){\n        return  this.state.list.map((item,index) => {\n            return <li key = {index}>{item}</li>\n        })\n    }\n")])])]),v("p",[e._v("由于"),v("code",[e._v("React中")]),e._v("的"),v("code",[e._v("setState")]),e._v("是"),v("code",[e._v("异步操作")]),e._v("，所以你其实可以"),v("code",[e._v("传递函数")]),e._v("来"),v("code",[e._v("替代传递对象")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    // 原来同步的写法\n    this.setState({\n        list: ['1','2']\n    })\n\n    // 现在的异步写法\n    this.setState(()=>{\n        return {\n            list: ['1','2']\n        }\n    })\n\n    // 再简化一下\n    this.setState(()=>({list: ['1','2']}));\n")])])]),v("p",[e._v("如果你使用了 "),v("code",[e._v("异步写法")]),e._v("，那么"),v("code",[e._v("注意")]),e._v("了，"),v("code",[e._v("如果使用了event对象")]),e._v("，"),v("code",[e._v("那么要将值先保存一下")]),e._v("，因为"),v("code",[e._v("异步")]),e._v("的"),v("code",[e._v("写法获取不到 event")]),e._v("对象的，就像"),v("code",[e._v("for循环")]),e._v("里面"),v("code",[e._v("写函数获取不到")]),e._v("每次的"),v("code",[e._v("i")]),e._v("一样。")]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    handleInput(evnet) {\n        const value = event.value;\n        this.setState({} => ({inputValue: value}));\n    }\n")])])]),v("p",[e._v("当使用了异步的写法后，你可以通过函数里传递过来的参数来替代"),v("code",[e._v("this.state")])]),e._v(" "),v("div",{staticClass:"language-react extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("        // 再简化一下\n    this.setState((preState)=>(\n            {\n                list: [...preState.list,inputValue],\n                inputValue: ''\n            }\n        )\n    );\n")])])]),v("p",[v("code",[e._v("循环")]),e._v("的"),v("code",[e._v("时")]),e._v("候"),v("code",[e._v("key")]),e._v("的属性因该"),v("code",[e._v("放")]),e._v("到"),v("code",[e._v("循环体")]),e._v("的"),v("code",[e._v("最外")]),e._v("的那个"),v("code",[e._v("元素上")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),v("h3",{attrs:{id:"声明式与命令式开发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#声明式与命令式开发"}},[e._v("#")]),e._v(" 声明式与命令式开发")]),e._v(" "),v("p",[v("code",[e._v("声明式开发")]),e._v("方式：使"),v("code",[e._v("用框架")]),e._v("来"),v("code",[e._v("操作DOM")]),e._v("，如 React、Vue，减少 DOM 操作。"),v("br"),e._v(" "),v("code",[e._v("命令式开发")]),e._v("方式："),v("code",[e._v("直接操作DOM")]),e._v(" ，如 jQuery")]),e._v(" "),v("h3",{attrs:{id:"与其它框架并存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与其它框架并存"}},[e._v("#")]),e._v(" 与其它框架"),v("code",[e._v("并存")])]),e._v(" "),v("p",[v("code",[e._v("React")]),e._v(" 最终有一个"),v("code",[e._v("ReactDOM.Render")]),e._v("方法，这个方法会"),v("code",[e._v("将组件渲染成DOM填充页面中容器")]),e._v("。"),v("br"),e._v("\n也就是说，它最后只会填充那个容器，页面其它的容器它管不着，其它的容器你就可以使用其它的技术，如 Vue，Jquery 等等。"),v("br"),e._v("\n这就是 React 可以与其它框架并存的原因。")]),e._v(" "),v("h3",{attrs:{id:"组件式的开发-组件化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件式的开发-组件化"}},[e._v("#")]),e._v(" 组件式的开发（组件化）")]),e._v(" "),v("p",[e._v("首字母大写就是组件，首字母小写就是 html 元素"),v("br"),e._v("\n父子传值 通过属性的方式，父组件中给子组件设置属性，子组件中通过 this.props 获取属性。"),v("br"),e._v("\n子父传值，也是一样，只不过传递的是父组件中的方法，但是每个方法都要.bind(this),表示将父组件中的方法的 this 指向父组件，这样子组件调用的时候才有效。")]),e._v(" "),v("h3",{attrs:{id:"单向数据流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流"}},[e._v("#")]),e._v(" 单向数据流")]),e._v(" "),v("p",[e._v("父组件可以给子组件传递值，但是子组件一定不能够直接去修改父组件的值，一旦你改变了，React 会给你报一个错误出来，因为传递过来的值是一个只读的属性。")]),e._v(" "),v("p",[e._v("单向数据流是为了让测试起来和开发起来方便，不容易遇到坑。")]),e._v(" "),v("p",[e._v("如果父组件中有五六个组件，都传递了同一个值，然后你在其中一个子组件中直接修改父组件传递给你的那个属性，那么其它的组件就完蛋了。"),v("br"),e._v("\n虽然最后还是会修改父组件中的那个属性，但是那不一定，因为 setState 这个操作是异步进行的，前面的修改某个属性的操作，会被后面修改某个属性的操作覆盖掉，只执行最后一次操作。")]),e._v(" "),v("p",[e._v("如果页面出现了 bug，你调试起来也不方便，因为你这个属性被五六个组件公用了，都可以直接修改值，这样很不好。"),v("br"),e._v("\n所以 React 出了单向数据流，只允许父组件向子组件传递数据，但是不允许子组件直接修改父组件传递过去的数据，你可以通过父组件传递过去的方法，来修改父组件中的数据。"),v("br"),e._v("\n单向数据流代码维护方便。")]),e._v(" "),v("h3",{attrs:{id:"视图层的框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#视图层的框架"}},[e._v("#")]),e._v(" 视图层的框架")]),e._v(" "),v("p",[e._v("做大型项目时传值是一个问题，所以需要配合一个数据层的框架，帮我们解决 React 中组件间复杂传值的问题。"),v("br"),e._v("\n如 兄弟组件间传值，这个最麻烦，一层一层往上，再一层一层的往下，项目很大，那就会崩溃。代码冗余。"),v("br"),e._v("\n所以 React 就把它定义为一个视图层的框架，它并不是什么问题都解决，我只帮你解决数据和视图在页面渲染的问题，至于组件之间传值我并不负责，我交给其它组件来做。"),v("br"),e._v("\n如果只有两层组件，借助 React 内部的传值机制就可以了，如果有多层组件，就是用"),v("code",[e._v("Redux")]),e._v("等等数据层框架来辅助。"),v("br"),e._v("\n这也是为什么"),v("code",[e._v("React")]),e._v("将自己称为"),v("code",[e._v("一个视图层的框架")]),e._v("，而"),v("code",[e._v("不是一个大型的完整的框架")]),e._v("，"),v("code",[e._v("它会借助很多的辅助框架")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"函数式编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[e._v("#")]),e._v(" 函数式编程")]),e._v(" "),v("p",[e._v("面向测试的开发流程，前端自动化测试的时候，如果你的代码都是一个个函数，那么测试时就调用这个函数，查看输入输出即可，这样就给前端自动化测试带来很大的便利。")])])}),[],!1,null,null,null);t.default=a.exports}}]);